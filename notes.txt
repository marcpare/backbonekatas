

2013-10-25

Code review, compare to existing TodoMVC implementation 

- Use ternary operator for checked
- Cache template as object property
- Replace multiple listens to rerender with 'all' listener
- Get the checked state of a checkbox with `this.allCheckbox.checked`
- The jquery id selected returns a collections, not the element
- Using `where` on a Model doesn't make sense because properties are in `attributes`
- Use `toggleClass` with a Boolean param (instead of trying to keep track of toggled on/toggled off)
- Remove a view by listening to the model's destroy event rather than manually removing it when you destroy it

Next up:

- Edit a TODO (save the edit)
- Filter completed
- Filter all

Review: is there a cleaner way to open and close the edit box?

2013-10-24

Discovered: use Dash app for documentation.
I ended up reading lots more of the Underscore and Backbone
docs this way. Very quick and easy to explore different functions
in the library this way.

When modifying attributes in a Model use get/set, don't do
it directly (because they're stored in the `attributes`
property)

Review: I've implemented the `completed` toggling
in a kind of ugly way. Is there a way to just integrate it
into the template?

Review: setting the order parameter. I put it in the collection,
listed to the add event on the collection.

Review: how to trigger a render of app-view on page load?

***

2013-10-23

It's possible to iterate through a collection in a template,
but the TODO MVC example does not. It appends as you add elements.

Setting `id: todo-app` instead of `el: #todo-app` broke the event
binding.

This is a consequence of _ensureElement

// If `this.el` is a string, pass it through `$()`, take the first
// matching element, and re-assign it to `el`. Otherwise, create
// an element from the `id`, `className` and `tagName` properties.

Setting `this.el` looks up the element, anything else *creates*
a new one.

Initialize a hash `options || (options = {})`

- Added a todo on form input. Feel like magic, no DOM manipulation
- Added class toggling for completed items
- Delete a todo
- Store in local storage

I was using `sync` instead of `fetch`.


***

2013-10-22

What triggers the render event?

I was reading some Haskell yesterday, and it seemed straightforward. Is "learning programming languages" a mental mode?

Why does clearCompleted return false?


Compare these two forms of the same thing.
The mental model is: use functional constructs to contain the pattern
of invocation (like "call an objects method for each item in a list" = invoke)
Instead of reimplementing it.
(wow, that is kind of opaque with words, but I can see the shape in my head easily)
<pre>
app.todos.each(function(todo){
  if(todo.get('completed')){
   todo.destroy();
  }
});

_.invoke(app.todos.completed(), 'destroy');`
</pre>


why is adding the context necessary? could I delete it?
`app.todos.each(this.filterOne, this);`

I deleted it and the filtering worked fine.
`app.todos.each(this.filterOne);`

Opened an issue about it. What will happen?

> It does because filterOne is not actually relying on the binding of this to the current object. If, however, at some point in the future the code would change and would add a dependency on this, it would break. I think keeping the context parameter around there is good style.

An interesting stylistic consequence of prototypal inheritance.

evening
-------

Do it from scratch, only using the docs.

- Able to make a Todo model
- Give it a view, render a template for the view
- But got stuck trying to render a collection (got unstuck peeking at app-view.js) 

A mistake I've made twice:

- when constructing a View or Model, specify the properties as a dict (not args)

A zen of "no look": you really want to have "the answer". There seem to be too
many things to get right. Take it one line at a time. There is no answer, there
are infinitely many answers (and, what you would really like, a better answer than
the one you've got in hand)

***

2013-10-21

Now I'm building it up one feature at a time, trying to add only the code that supports that feature.

First: the adding a TODO
Then,
* editing a todo
  - did an edit, doesn't show till page refresh
* delete a todo
* check off a todo
* mark all as complete
  
  
Why do you have some of the events as object-level (prototype-level?) properties,
then, some added later in initialize?

What events go where?

The source says `listenTo` is an inversion of control of `on`. Does that mean
that listenTo is for when you want another object's events?

  events: {
    'dblclick label': 'edit',
    'blur .edit': 'close',
    'keypress .edit': 'updateOnEnter'
  },
  initialize: function(){
    this.listenTo(this.model, 'change', this.render);
  }

***

Initialize a property as an empty dictionary:

`var listeningTo = this._listeningTo || (this._listeningTo = {});`

Works with any default value:

`var id = obj._listenId || (obj._listenId = _.uniqueId('l'));`

***

an idiomatic loop for traversing an array:
(the `length` call is slow, and it would be called each iteration
if it were part of the loop boundary statement)

var i, l;
for (i = 0, l = names.length; i < l; i++) {
}

***

I tossed in a little variation here:

<pre>
app.todos.each(function(todo){
  todo.save({'completed':completed});
});
</pre>

<pre>
app.todos.each(function(todo){
  todo.set('completed', completed);
  todo.save();
});
</pre>

***

I did the exercise this way: read the code. Flip to my editor, try to type from memory.
Try to come up with a mental model of the methods so that you can recreate yourself.



2013-10-20

TODO:
-----

/* uses apply because completed() returns a list which we want to expand */
`return this.without.apply(this, this.completed());`


Run JSLint
Is there a JSLint workflow?
What do Grunt tasks for backbone look like?
Would this be faster in coffeescript?

Can I type multiple lines of code with resorting to the arrow keys?

What is the purpose of 
`var app = app || {};`
at the start of each of the files?



// A difficult-to-believe, but optimized internal dispatch function for
// triggering events. Tries to keep the usual cases speedy (most internal
// Backbone events have 3 arguments).
var triggerEvents = function(events, args) {
  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
  
  switch (args.length) {
    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
  }
};

I think it's because call is faster than apply?

http://jsperf.com/test-call-vs-apply/34